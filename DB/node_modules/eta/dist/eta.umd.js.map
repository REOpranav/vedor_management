{"version":3,"file":"eta.umd.js","sources":["../src/storage.ts","../src/err.ts","../src/compile.ts","../src/compile-string.ts","../src/utils.ts","../src/config.ts","../src/parse.ts","../src/render.ts","../src/core.ts","../src/file-handling.ts","../src/index.ts"],"sourcesContent":["/**\n * Handles storage and accessing of values\n *\n * In this case, we use it to store compiled template functions\n * Indexed by their `name` or `filename`\n */\n\nexport class Cacher<T> {\n  constructor(private cache: Record<string, T>) {}\n  define(key: string, val: T): void {\n    this.cache[key] = val;\n  }\n  get(key: string): T {\n    return this.cache[key];\n  }\n  remove(key: string): void {\n    delete this.cache[key];\n  }\n  reset(): void {\n    this.cache = {};\n  }\n  load(cacheObj: Record<string, T>): void {\n    this.cache = { ...this.cache, ...cacheObj };\n  }\n}\n","export class EtaError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"Eta Error\";\n  }\n}\n\nexport class EtaParseError extends EtaError {\n  constructor(message: string) {\n    super(message);\n    this.name = \"EtaParser Error\";\n  }\n}\n\nexport class EtaRuntimeError extends EtaError {\n  constructor(message: string) {\n    super(message);\n    this.name = \"EtaRuntime Error\";\n  }\n}\n\nexport class EtaFileResolutionError extends EtaError {\n  constructor(message: string) {\n    super(message);\n    this.name = \"EtaFileResolution Error\";\n  }\n}\n\nexport class EtaNameResolutionError extends EtaError {\n  constructor(message: string) {\n    super(message);\n    this.name = \"EtaNameResolution Error\";\n  }\n}\n\n/**\n * Throws an EtaError with a nicely formatted error and message showing where in the template the error occurred.\n */\n\nexport function ParseErr(message: string, str: string, indx: number): never {\n  const whitespace = str.slice(0, indx).split(/\\n/);\n\n  const lineNo = whitespace.length;\n  const colNo = whitespace[lineNo - 1].length + 1;\n  message += \" at line \" +\n    lineNo +\n    \" col \" +\n    colNo +\n    \":\\n\\n\" +\n    \"  \" +\n    str.split(/\\n/)[lineNo - 1] +\n    \"\\n\" +\n    \"  \" +\n    Array(colNo).join(\" \") +\n    \"^\";\n  throw new EtaParseError(message);\n}\n\nexport function RuntimeErr(\n  originalError: Error,\n  str: string,\n  lineNo: number,\n  path: string,\n): never {\n  // code gratefully taken from https://github.com/mde/ejs and adapted\n\n  const lines = str.split(\"\\n\");\n  const start = Math.max(lineNo - 3, 0);\n  const end = Math.min(lines.length, lineNo + 3);\n  const filename = path;\n  // Error context\n  const context = lines\n    .slice(start, end)\n    .map(function (line, i) {\n      const curr = i + start + 1;\n      return (curr == lineNo ? \" >> \" : \"    \") + curr + \"| \" + line;\n    })\n    .join(\"\\n\");\n\n  const header = filename\n    ? filename + \":\" + lineNo + \"\\n\"\n    : \"line \" + lineNo + \"\\n\";\n\n  const err = new EtaRuntimeError(\n    header + context + \"\\n\\n\" + originalError.message,\n  );\n\n  err.name = originalError.name; // the original name (e.g. ReferenceError) may be useful\n\n  throw err;\n}\n","import { EtaParseError } from \"./err.ts\";\n\n/* TYPES */\nimport type { Eta } from \"./core.ts\";\nimport type { EtaConfig, Options } from \"./config.ts\";\n\nexport type TemplateFunction = (\n  this: Eta,\n  data?: object,\n  options?: Partial<Options>,\n) => string;\n/* END TYPES */\n\n/* istanbul ignore next */\nconst AsyncFunction = async function () {}.constructor; // eslint-disable-line @typescript-eslint/no-empty-function\n\n/**\n * Takes a template string and returns a template function that can be called with (data, config)\n *\n * @param str - The template string\n * @param config - A custom configuration object (optional)\n */\n\nexport function compile(\n  this: Eta,\n  str: string,\n  options?: Partial<Options>,\n): TemplateFunction {\n  const config: EtaConfig = this.config;\n\n  /* ASYNC HANDLING */\n  // code gratefully taken from https://github.com/mde/ejs and adapted\n  const ctor = options && options.async\n    ? (AsyncFunction as FunctionConstructor)\n    : Function;\n  /* END ASYNC HANDLING */\n\n  try {\n    return new ctor(\n      config.varName,\n      \"options\",\n      this.compileToString.call(this, str, options),\n    ) as TemplateFunction; // eslint-disable-line no-new-func\n  } catch (e) {\n    if (e instanceof SyntaxError) {\n      throw new EtaParseError(\n        \"Bad template syntax\\n\\n\" +\n          e.message +\n          \"\\n\" +\n          Array(e.message.length + 1).join(\"=\") +\n          \"\\n\" +\n          this.compileToString.call(this, str, options) +\n          \"\\n\", // This will put an extra newline before the callstack for extra readability\n      );\n    } else {\n      throw e;\n    }\n  }\n}\n","/* TYPES */\n\nimport type { Options } from \"./config.ts\";\nimport type { AstObject } from \"./parse.ts\";\nimport type { Eta } from \"./core.ts\";\n\n/* END TYPES */\n\n/**\n * Compiles a template string to a function string. Most often users just use `compile()`, which calls `compileToString` and creates a new function using the result\n */\n\nexport function compileToString(\n  this: Eta,\n  str: string,\n  options?: Partial<Options>,\n): string {\n  const config = this.config;\n  const isAsync = options && options.async;\n\n  const compileBody = this.compileBody;\n\n  const buffer: Array<AstObject> = this.parse.call(this, str);\n\n  // note: when the include function passes through options, the only parameter that matters is the filepath parameter\n  let res = `${config.functionHeader}\nlet include = (template, data) => this.render(template, data, options);\nlet includeAsync = (template, data) => this.renderAsync(template, data, options);\n\nlet __eta = {res: \"\", e: this.config.escapeFunction, f: this.config.filterFunction${\n    config.debug\n      ? ', line: 1, templateStr: \"' +\n        str.replace(/\\\\|\"/g, \"\\\\$&\").replace(/\\r\\n|\\n|\\r/g, \"\\\\n\") +\n        '\"'\n      : \"\"\n  }};\n\nfunction layout(path, data) {\n  __eta.layout = path;\n  __eta.layoutData = data;\n}${config.debug ? \"try {\" : \"\"}${\n    config.useWith ? \"with(\" + config.varName + \"||{}){\" : \"\"\n  }\n\n${compileBody.call(this, buffer)}\nif (__eta.layout) {\n  __eta.res = ${\n    isAsync ? \"await includeAsync\" : \"include\"\n  } (__eta.layout, {...${config.varName}, body: __eta.res, ...__eta.layoutData});\n}\n${config.useWith ? \"}\" : \"\"}${\n    config.debug\n      ? \"} catch (e) { this.RuntimeErr(e, __eta.templateStr, __eta.line, options.filepath) }\"\n      : \"\"\n  }\nreturn __eta.res;\n`;\n\n  if (config.plugins) {\n    for (let i = 0; i < config.plugins.length; i++) {\n      const plugin = config.plugins[i];\n      if (plugin.processFnString) {\n        res = plugin.processFnString(res, config);\n      }\n    }\n  }\n\n  return res;\n}\n\n/**\n * Loops through the AST generated by `parse` and transform each item into JS calls\n *\n * **Example**\n *\n * ```js\n * let templateAST = ['Hi ', { val: 'it.name', t: 'i' }]\n * compileBody.call(Eta, templateAST)\n * // => \"__eta.res+='Hi '\\n__eta.res+=__eta.e(it.name)\\n\"\n * ```\n */\n\nexport function compileBody(this: Eta, buff: Array<AstObject>): string {\n  const config = this.config;\n\n  let i = 0;\n  const buffLength = buff.length;\n  let returnStr = \"\";\n\n  for (i; i < buffLength; i++) {\n    const currentBlock = buff[i];\n    if (typeof currentBlock === \"string\") {\n      const str = currentBlock;\n\n      // we know string exists\n      returnStr += \"__eta.res+='\" + str + \"'\\n\";\n    } else {\n      const type = currentBlock.t; // \"r\", \"e\", or \"i\"\n      let content = currentBlock.val || \"\";\n\n      if (config.debug) returnStr += \"__eta.line=\" + currentBlock.lineNo + \"\\n\";\n\n      if (type === \"r\") {\n        // raw\n\n        if (config.autoFilter) {\n          content = \"__eta.f(\" + content + \")\";\n        }\n\n        returnStr += \"__eta.res+=\" + content + \"\\n\";\n      } else if (type === \"i\") {\n        // interpolate\n\n        if (config.autoFilter) {\n          content = \"__eta.f(\" + content + \")\";\n        }\n\n        if (config.autoEscape) {\n          content = \"__eta.e(\" + content + \")\";\n        }\n\n        returnStr += \"__eta.res+=\" + content + \"\\n\";\n      } else if (type === \"e\") {\n        // execute\n        returnStr += content + \"\\n\";\n      }\n    }\n  }\n\n  return returnStr;\n}\n","import type { EtaConfig } from \"./config.ts\";\n\n/**\n * Takes a string within a template and trims it, based on the preceding tag's whitespace control and `config.autoTrim`\n */\n\nexport function trimWS(\n  str: string,\n  config: EtaConfig,\n  wsLeft: string | false,\n  wsRight?: string | false,\n): string {\n  let leftTrim;\n  let rightTrim;\n\n  if (Array.isArray(config.autoTrim)) {\n    // Slightly confusing,\n    // but _}} will trim the left side of the following string\n    leftTrim = config.autoTrim[1];\n    rightTrim = config.autoTrim[0];\n  } else {\n    leftTrim = rightTrim = config.autoTrim;\n  }\n\n  if (wsLeft || wsLeft === false) {\n    leftTrim = wsLeft;\n  }\n\n  if (wsRight || wsRight === false) {\n    rightTrim = wsRight;\n  }\n\n  if (!rightTrim && !leftTrim) {\n    return str;\n  }\n\n  if (leftTrim === \"slurp\" && rightTrim === \"slurp\") {\n    return str.trim();\n  }\n\n  if (leftTrim === \"_\" || leftTrim === \"slurp\") {\n    // full slurp\n    str = str.trimStart();\n  } else if (leftTrim === \"-\" || leftTrim === \"nl\") {\n    // nl trim\n    str = str.replace(/^(?:\\r\\n|\\n|\\r)/, \"\");\n  }\n\n  if (rightTrim === \"_\" || rightTrim === \"slurp\") {\n    // full slurp\n    str = str.trimEnd();\n  } else if (rightTrim === \"-\" || rightTrim === \"nl\") {\n    // nl trim\n    str = str.replace(/(?:\\r\\n|\\n|\\r)$/, \"\");\n  }\n\n  return str;\n}\n\n/**\n * A map of special HTML characters to their XML-escaped equivalents\n */\n\nconst escMap: { [key: string]: string } = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n  '\"': \"&quot;\",\n  \"'\": \"&#39;\",\n};\n\nfunction replaceChar(s: string): string {\n  return escMap[s];\n}\n\n/**\n * XML-escapes an input value after converting it to a string\n *\n * @param str - Input value (usually a string)\n * @returns XML-escaped string\n */\n\nexport function XMLEscape(str: unknown): string {\n  // To deal with XSS. Based on Escape implementations of Mustache.JS and Marko, then customized.\n  const newStr = String(str);\n  if (/[&<>\"']/.test(newStr)) {\n    return newStr.replace(/[&<>\"']/g, replaceChar);\n  } else {\n    return newStr;\n  }\n}\n","import { XMLEscape } from \"./utils.ts\";\n\n/* TYPES */\n\ntype trimConfig = \"nl\" | \"slurp\" | false;\n\nexport interface Options {\n  /** Compile to async function */\n  async?: boolean;\n\n  /** Absolute path to template file */\n  filepath?: string;\n}\n\nexport interface EtaConfig {\n  /** Whether or not to automatically XML-escape interpolations. Default true */\n  autoEscape: boolean;\n\n  /** Apply a filter function defined on the class to every interpolation or raw interpolation */\n  autoFilter: boolean;\n\n  /** Configure automatic whitespace trimming. Default `[false, 'nl']` */\n  autoTrim: trimConfig | [trimConfig, trimConfig];\n\n  /** Whether or not to cache templates if `name` or `filename` is passed */\n  cache: boolean;\n\n  /** Holds cache of resolved filepaths. Set to `false` to disable. */\n  cacheFilepaths: boolean;\n\n  /** Whether to pretty-format error messages (introduces runtime penalties) */\n  debug: boolean;\n\n  /** Function to XML-sanitize interpolations */\n  escapeFunction: (str: unknown) => string;\n\n  /** Function applied to all interpolations when autoFilter is true */\n  filterFunction: (val: unknown) => string;\n\n  /** Raw JS code inserted in the template function. Useful for declaring global variables for user templates */\n  functionHeader: string;\n\n  /** Parsing options */\n  parse: {\n    /** Which prefix to use for evaluation. Default `\"\"`, does not support `\"-\"` or `\"_\"` */\n    exec: string;\n\n    /** Which prefix to use for interpolation. Default `\"=\"`, does not support `\"-\"` or `\"_\"` */\n    interpolate: string;\n\n    /** Which prefix to use for raw interpolation. Default `\"~\"`, does not support `\"-\"` or `\"_\"` */\n    raw: string;\n  };\n\n  /** Array of plugins */\n  plugins: Array<\n    {\n      processFnString?: Function;\n      processAST?: Function;\n      processTemplate?: Function;\n    }\n  >;\n\n  /** Remove all safe-to-remove whitespace */\n  rmWhitespace: boolean;\n\n  /** Delimiters: by default `['<%', '%>']` */\n  tags: [string, string];\n\n  /** Make data available on the global object instead of varName */\n  useWith: boolean;\n\n  /** Name of the data object. Default `it` */\n  varName: string;\n\n  /** Directory that contains templates */\n  views?: string;\n\n  /** Control template file extension defaults. Default `.eta` */\n  defaultExtension?: string;\n}\n\n/* END TYPES */\n\n/** Eta's base (global) configuration */\nconst defaultConfig: EtaConfig = {\n  autoEscape: true,\n  autoFilter: false,\n  autoTrim: [false, \"nl\"],\n  cache: false,\n  cacheFilepaths: true,\n  debug: false,\n  escapeFunction: XMLEscape,\n  // default filter function (not used unless enables) just stringifies the input\n  filterFunction: (val) => String(val),\n  functionHeader: \"\",\n  parse: {\n    exec: \"\",\n    interpolate: \"=\",\n    raw: \"~\",\n  },\n  plugins: [],\n  rmWhitespace: false,\n  tags: [\"<%\", \"%>\"],\n  useWith: false,\n  varName: \"it\",\n  defaultExtension: \".eta\",\n};\n\nexport { defaultConfig };\n","import { ParseErr } from \"./err.ts\";\nimport { trimWS } from \"./utils.ts\";\n\n/* TYPES */\n\nimport type { Eta } from \"./core.ts\";\n\nexport type TagType = \"r\" | \"e\" | \"i\" | \"\";\n\nexport interface TemplateObject {\n  t: TagType;\n  val: string;\n  lineNo?: number;\n}\n\nexport type AstObject = string | TemplateObject;\n\n/* END TYPES */\n\nconst templateLitReg =\n  /`(?:\\\\[\\s\\S]|\\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})*}|(?!\\${)[^\\\\`])*`/g;\n\nconst singleQuoteReg = /'(?:\\\\[\\s\\w\"'\\\\`]|[^\\n\\r'\\\\])*?'/g;\n\nconst doubleQuoteReg = /\"(?:\\\\[\\s\\w\"'\\\\`]|[^\\n\\r\"\\\\])*?\"/g;\n\n/** Escape special regular expression characters inside a string */\n\nfunction escapeRegExp(string: string) {\n  // From MDN\n  return string.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\n}\n\nfunction getLineNo(str: string, index: number) {\n  return str.slice(0, index).split(\"\\n\").length;\n}\n\nexport function parse(this: Eta, str: string): Array<AstObject> {\n  const config = this.config;\n\n  let buffer: Array<AstObject> = [];\n  let trimLeftOfNextStr: string | false = false;\n  let lastIndex = 0;\n  const parseOptions = config.parse;\n\n  if (config.plugins) {\n    for (let i = 0; i < config.plugins.length; i++) {\n      const plugin = config.plugins[i];\n      if (plugin.processTemplate) {\n        str = plugin.processTemplate(str, config);\n      }\n    }\n  }\n\n  /* Adding for EJS compatibility */\n  if (config.rmWhitespace) {\n    // Code taken directly from EJS\n    // Have to use two separate replaces here as `^` and `$` operators don't\n    // work well with `\\r` and empty lines don't work well with the `m` flag.\n    // Essentially, this replaces the whitespace at the beginning and end of\n    // each line and removes multiple newlines.\n    str = str.replace(/[\\r\\n]+/g, \"\\n\").replace(/^\\s+|\\s+$/gm, \"\");\n  }\n  /* End rmWhitespace option */\n\n  templateLitReg.lastIndex = 0;\n  singleQuoteReg.lastIndex = 0;\n  doubleQuoteReg.lastIndex = 0;\n\n  function pushString(strng: string, shouldTrimRightOfString?: string | false) {\n    if (strng) {\n      // if string is truthy it must be of type 'string'\n\n      strng = trimWS(\n        strng,\n        config,\n        trimLeftOfNextStr, // this will only be false on the first str, the next ones will be null or undefined\n        shouldTrimRightOfString,\n      );\n\n      if (strng) {\n        // replace \\ with \\\\, ' with \\'\n        // we're going to convert all CRLF to LF so it doesn't take more than one replace\n\n        strng = strng.replace(/\\\\|'/g, \"\\\\$&\").replace(/\\r\\n|\\n|\\r/g, \"\\\\n\");\n\n        buffer.push(strng);\n      }\n    }\n  }\n\n  const prefixes = [\n    parseOptions.exec,\n    parseOptions.interpolate,\n    parseOptions.raw,\n  ].reduce(function (\n    accumulator,\n    prefix,\n  ) {\n    if (accumulator && prefix) {\n      return accumulator + \"|\" + escapeRegExp(prefix);\n    } else if (prefix) {\n      // accumulator is falsy\n      return escapeRegExp(prefix);\n    } else {\n      // prefix and accumulator are both falsy\n      return accumulator;\n    }\n  }, \"\");\n\n  const parseOpenReg = new RegExp(\n    escapeRegExp(config.tags[0]) + \"(-|_)?\\\\s*(\" + prefixes + \")?\\\\s*\",\n    \"g\",\n  );\n\n  const parseCloseReg = new RegExp(\n    \"'|\\\"|`|\\\\/\\\\*|(\\\\s*(-|_)?\" + escapeRegExp(config.tags[1]) + \")\",\n    \"g\",\n  );\n\n  let m;\n\n  while ((m = parseOpenReg.exec(str))) {\n    const precedingString = str.slice(lastIndex, m.index);\n\n    lastIndex = m[0].length + m.index;\n\n    const wsLeft = m[1];\n    const prefix = m[2] || \"\"; // by default either ~, =, or empty\n\n    pushString(precedingString, wsLeft);\n\n    parseCloseReg.lastIndex = lastIndex;\n    let closeTag;\n    let currentObj: AstObject | false = false;\n\n    while ((closeTag = parseCloseReg.exec(str))) {\n      if (closeTag[1]) {\n        const content = str.slice(lastIndex, closeTag.index);\n\n        parseOpenReg.lastIndex = lastIndex = parseCloseReg.lastIndex;\n\n        trimLeftOfNextStr = closeTag[2];\n\n        const currentType: TagType = prefix === parseOptions.exec\n          ? \"e\"\n          : prefix === parseOptions.raw\n          ? \"r\"\n          : prefix === parseOptions.interpolate\n          ? \"i\"\n          : \"\";\n\n        currentObj = { t: currentType, val: content };\n        break;\n      } else {\n        const char = closeTag[0];\n        if (char === \"/*\") {\n          const commentCloseInd = str.indexOf(\"*/\", parseCloseReg.lastIndex);\n\n          if (commentCloseInd === -1) {\n            ParseErr(\"unclosed comment\", str, closeTag.index);\n          }\n          parseCloseReg.lastIndex = commentCloseInd;\n        } else if (char === \"'\") {\n          singleQuoteReg.lastIndex = closeTag.index;\n\n          const singleQuoteMatch = singleQuoteReg.exec(str);\n          if (singleQuoteMatch) {\n            parseCloseReg.lastIndex = singleQuoteReg.lastIndex;\n          } else {\n            ParseErr(\"unclosed string\", str, closeTag.index);\n          }\n        } else if (char === '\"') {\n          doubleQuoteReg.lastIndex = closeTag.index;\n          const doubleQuoteMatch = doubleQuoteReg.exec(str);\n\n          if (doubleQuoteMatch) {\n            parseCloseReg.lastIndex = doubleQuoteReg.lastIndex;\n          } else {\n            ParseErr(\"unclosed string\", str, closeTag.index);\n          }\n        } else if (char === \"`\") {\n          templateLitReg.lastIndex = closeTag.index;\n          const templateLitMatch = templateLitReg.exec(str);\n          if (templateLitMatch) {\n            parseCloseReg.lastIndex = templateLitReg.lastIndex;\n          } else {\n            ParseErr(\"unclosed string\", str, closeTag.index);\n          }\n        }\n      }\n    }\n    if (currentObj) {\n      if (config.debug) {\n        currentObj.lineNo = getLineNo(str, m.index);\n      }\n      buffer.push(currentObj);\n    } else {\n      ParseErr(\"unclosed tag\", str, m.index);\n    }\n  }\n\n  pushString(str.slice(lastIndex, str.length), false);\n\n  if (config.plugins) {\n    for (let i = 0; i < config.plugins.length; i++) {\n      const plugin = config.plugins[i];\n      if (plugin.processAST) {\n        buffer = plugin.processAST(buffer, config);\n      }\n    }\n  }\n\n  return buffer;\n}\n","import { EtaNameResolutionError } from \"./err.ts\";\n\n/* TYPES */\nimport type { Options } from \"./config.ts\";\nimport type { TemplateFunction } from \"./compile.ts\";\nimport type { Eta } from \"./core.ts\";\n/* END TYPES */\n\nfunction handleCache(\n  this: Eta,\n  template: string,\n  options: Partial<Options>,\n): TemplateFunction {\n  const templateStore = options && options.async\n    ? this.templatesAsync\n    : this.templatesSync;\n\n  if (this.resolvePath && this.readFile && !template.startsWith(\"@\")) {\n    const templatePath = options.filepath as string;\n\n    const cachedTemplate = templateStore.get(templatePath);\n\n    if (this.config.cache && cachedTemplate) {\n      return cachedTemplate;\n    } else {\n      const templateString = this.readFile(templatePath);\n\n      const templateFn = this.compile(templateString, options);\n\n      if (this.config.cache) templateStore.define(templatePath, templateFn);\n\n      return templateFn;\n    }\n  } else {\n    const cachedTemplate = templateStore.get(template);\n\n    if (cachedTemplate) {\n      return cachedTemplate;\n    } else {\n      throw new EtaNameResolutionError(\n        \"Failed to get template '\" + template + \"'\",\n      );\n    }\n  }\n}\n\nexport function render<T extends object>(\n  this: Eta,\n  template: string | TemplateFunction, // template name or template function\n  data: T,\n  meta?: { filepath: string },\n): string {\n  let templateFn: TemplateFunction;\n  const options = { ...meta, async: false };\n\n  if (typeof template === \"string\") {\n    if (this.resolvePath && this.readFile && !template.startsWith(\"@\")) {\n      options.filepath = this.resolvePath(template, options);\n    }\n\n    templateFn = handleCache.call(this, template, options);\n  } else {\n    templateFn = template;\n  }\n\n  const res = templateFn.call(this, data, options);\n\n  return res;\n}\n\nexport function renderAsync<T extends object>(\n  this: Eta,\n  template: string | TemplateFunction, // template name or template function\n  data: T,\n  meta?: { filepath: string },\n): Promise<string> {\n  let templateFn: TemplateFunction;\n  const options = { ...meta, async: true };\n\n  if (typeof template === \"string\") {\n    if (this.resolvePath && this.readFile && !template.startsWith(\"@\")) {\n      options.filepath = this.resolvePath(template, options);\n    }\n\n    templateFn = handleCache.call(this, template, options);\n  } else {\n    templateFn = template;\n  }\n\n  const res = templateFn.call(this, data, options);\n\n  // Return a promise\n  return Promise.resolve(res);\n}\n\nexport function renderString<T extends object>(\n  this: Eta,\n  template: string,\n  data: T,\n): string {\n  const templateFn = this.compile(template, { async: false });\n\n  return render.call(this, templateFn, data);\n}\n\nexport function renderStringAsync<T extends object>(\n  this: Eta,\n  template: string,\n  data: T,\n): Promise<string> {\n  const templateFn = this.compile(template, { async: true });\n\n  return renderAsync.call(this, templateFn, data);\n}\n","import { Cacher } from \"./storage.ts\";\nimport { compile } from \"./compile.ts\";\nimport { compileBody, compileToString } from \"./compile-string.ts\";\nimport { defaultConfig } from \"./config.ts\";\nimport { parse } from \"./parse.ts\";\nimport {\n  render,\n  renderAsync,\n  renderString,\n  renderStringAsync,\n} from \"./render.ts\";\nimport { EtaError, RuntimeErr } from \"./err.ts\";\nimport { TemplateFunction } from \"./compile.ts\";\n\n/* TYPES */\nimport type { EtaConfig, Options } from \"./config.ts\";\n/* END TYPES */\n\nexport class Eta {\n  constructor(customConfig?: Partial<EtaConfig>) {\n    if (customConfig) {\n      this.config = { ...defaultConfig, ...customConfig };\n    } else {\n      this.config = { ...defaultConfig };\n    }\n  }\n\n  config: EtaConfig;\n\n  RuntimeErr = RuntimeErr;\n\n  compile = compile;\n  compileToString = compileToString;\n  compileBody = compileBody;\n  parse = parse;\n  render = render;\n  renderAsync = renderAsync;\n  renderString = renderString;\n  renderStringAsync = renderStringAsync;\n\n  filepathCache: Record<string, string> = {};\n  templatesSync: Cacher<TemplateFunction> = new Cacher<TemplateFunction>({});\n  templatesAsync: Cacher<TemplateFunction> = new Cacher<TemplateFunction>({});\n\n  // resolvePath takes a relative path from the \"views\" directory\n  resolvePath:\n    | null\n    | ((this: Eta, template: string, options?: Partial<Options>) => string) =\n      null;\n  readFile: null | ((this: Eta, path: string) => string) = null;\n\n  // METHODS\n\n  configure(customConfig: Partial<EtaConfig>) {\n    this.config = { ...this.config, ...customConfig };\n  }\n\n  withConfig(customConfig: Partial<EtaConfig>): this & { config: EtaConfig } {\n    return { ...this, config: { ...this.config, ...customConfig } };\n  }\n\n  loadTemplate(\n    name: string,\n    template: string | TemplateFunction, // template string or template function\n    options?: { async: boolean },\n  ): void {\n    if (typeof template === \"string\") {\n      const templates = options && options.async\n        ? this.templatesAsync\n        : this.templatesSync;\n\n      templates.define(name, this.compile(template, options));\n    } else {\n      let templates = this.templatesSync;\n\n      if (\n        template.constructor.name === \"AsyncFunction\" ||\n        (options && options.async)\n      ) {\n        templates = this.templatesAsync;\n      }\n\n      templates.define(name, template);\n    }\n  }\n}\n\n// for instance checking against thrown errors\nexport { EtaError };\n","import { EtaFileResolutionError } from \"./err.ts\";\n\nimport * as path from \"node:path\";\n\nimport * as fs from \"node:fs\";\n\n/* TYPES */\nimport type { Eta as EtaCore } from \"./core.ts\";\nimport type { Options } from \"./config.ts\";\n/* END TYPES */\n\nexport function readFile(this: EtaCore, path: string): string {\n  let res = \"\";\n\n  try {\n    res = fs.readFileSync(path, \"utf8\");\n    // eslint-disable-line @typescript-eslint/no-explicit-any\n  } catch (err: any) {\n    if (err?.code === \"ENOENT\") {\n      throw new EtaFileResolutionError(`Could not find template: ${path}`);\n    } else {\n      throw err;\n    }\n  }\n\n  return res;\n}\n\nexport function resolvePath(\n  this: EtaCore,\n  templatePath: string,\n  options?: Partial<Options>,\n): string {\n  let resolvedFilePath = \"\";\n\n  const views = this.config.views;\n\n  if (!views) {\n    throw new EtaFileResolutionError(\"Views directory is not defined\");\n  }\n\n  const baseFilePath = options && options.filepath;\n  const defaultExtension = this.config.defaultExtension === undefined\n    ? \".eta\"\n    : this.config.defaultExtension;\n\n  // how we index cached template paths\n  const cacheIndex = JSON.stringify({\n    filename: baseFilePath, // filename of the template which called includeFile()\n    path: templatePath,\n    views: this.config.views,\n  });\n\n  templatePath += path.extname(templatePath) ? \"\" : defaultExtension;\n\n  // if the file was included from another template\n  if (baseFilePath) {\n    // check the cache\n\n    if (this.config.cacheFilepaths && this.filepathCache[cacheIndex]) {\n      return this.filepathCache[cacheIndex];\n    }\n\n    const absolutePathTest = absolutePathRegExp.exec(templatePath);\n\n    if (absolutePathTest && absolutePathTest.length) {\n      const formattedPath = templatePath.replace(/^\\/*|^\\\\*/, \"\");\n      resolvedFilePath = path.join(views, formattedPath);\n    } else {\n      resolvedFilePath = path.join(path.dirname(baseFilePath), templatePath);\n    }\n  } else {\n    resolvedFilePath = path.join(views, templatePath);\n  }\n\n  if (dirIsChild(views, resolvedFilePath)) {\n    // add resolved path to the cache\n    if (baseFilePath && this.config.cacheFilepaths) {\n      this.filepathCache[cacheIndex] = resolvedFilePath;\n    }\n\n    return resolvedFilePath;\n  } else {\n    throw new EtaFileResolutionError(\n      `Template '${templatePath}' is not in the views directory`,\n    );\n  }\n}\n\nfunction dirIsChild(parent: string, dir: string) {\n  const relative = path.relative(parent, dir);\n  return relative && !relative.startsWith(\"..\") && !path.isAbsolute(relative);\n}\n\nconst absolutePathRegExp = /^\\\\|^\\//;\n","import { Eta as EtaCore } from \"./core.ts\";\nimport { readFile, resolvePath } from \"./file-handling.ts\";\nexport {\n  EtaError,\n  EtaFileResolutionError,\n  EtaNameResolutionError,\n  EtaParseError,\n  EtaRuntimeError,\n} from \"./err.ts\";\nexport { type EtaConfig, type Options } from \"./config.ts\";\n\nexport class Eta extends EtaCore {\n  readFile = readFile;\n\n  resolvePath = resolvePath;\n}\n"],"names":["Cacher","constructor","cache","define","key","val","get","remove","reset","load","cacheObj","EtaError","Error","message","name","EtaParseError","EtaRuntimeError","EtaFileResolutionError","EtaNameResolutionError","ParseErr","str","indx","whitespace","slice","split","lineNo","length","colNo","Array","join","RuntimeErr","originalError","path","lines","start","Math","max","end","min","filename","context","map","line","i","curr","header","err","AsyncFunction","compile","options","config","ctor","async","Function","varName","compileToString","call","e","SyntaxError","isAsync","compileBody","buffer","parse","res","functionHeader","debug","replace","useWith","plugins","plugin","processFnString","buff","buffLength","returnStr","currentBlock","type","t","content","autoFilter","autoEscape","trimWS","wsLeft","wsRight","leftTrim","rightTrim","isArray","autoTrim","trim","trimStart","trimEnd","escMap","replaceChar","s","XMLEscape","newStr","String","test","defaultConfig","cacheFilepaths","escapeFunction","filterFunction","exec","interpolate","raw","rmWhitespace","tags","defaultExtension","templateLitReg","singleQuoteReg","doubleQuoteReg","escapeRegExp","string","getLineNo","index","trimLeftOfNextStr","lastIndex","parseOptions","processTemplate","pushString","strng","shouldTrimRightOfString","push","prefixes","reduce","accumulator","prefix","parseOpenReg","RegExp","parseCloseReg","m","precedingString","closeTag","currentObj","currentType","char","commentCloseInd","indexOf","singleQuoteMatch","doubleQuoteMatch","templateLitMatch","processAST","handleCache","template","templateStore","templatesAsync","templatesSync","resolvePath","readFile","startsWith","templatePath","filepath","cachedTemplate","templateString","templateFn","render","data","meta","renderAsync","Promise","resolve","renderString","renderStringAsync","Eta","customConfig","filepathCache","configure","withConfig","loadTemplate","templates","fs","readFileSync","code","resolvedFilePath","views","baseFilePath","undefined","cacheIndex","JSON","stringify","extname","absolutePathTest","absolutePathRegExp","formattedPath","dirname","dirIsChild","parent","dir","relative","isAbsolute","EtaCore","args"],"mappings":"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